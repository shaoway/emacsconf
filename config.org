#+AUTHOR: Shaowei Wang
#+TITLE: GNU Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./config.el :mkdirp yes

* Emacs initialization

** Local lisp file path setup
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/")
(add-to-list 'load-path "~/.emacs.d/site-lisp/themes")
#+end_src

** Package Sources

#+begin_src emacs-lisp
  (setq package-archives '(("elpa" . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
#+end_src

Install =use-package=

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package delight :ensure t)
#+end_src

* Start Up
** Better Defaults

*** DO NOT LET emacs littering backup files all over the place

People really don’t like Emacs’ littering.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  (defvar user-emacs-backup-directory
    (expand-file-name ".backup" user-emacs-directory))
  (defvar user-emacs-autosave-directory
    (expand-file-name ".autosave" user-emacs-directory))
  (unless (file-directory-p user-emacs-backup-directory)
    (make-directory user-emacs-backup-directory t))
  (unless (file-directory-p user-emacs-autosave-directory)
    (make-directory user-emacs-autosave-directory t))
  (setq auto-save-file-name-transforms `((".*" ,user-emacs-autosave-directory t)))
  (setq backup-directory-alist `(("." . ,user-emacs-backup-directory)))
  
#+end_src

*** Backs up by moving the actual file

The default is nil and that means that every time it makes one of those
backups~, it actually moves your file there, copies the backup to the original
name, and gives you the copy to work on. This isn’t just a philosophical dilemma
("Am I a butterfly that dreams I am a backup~?") but actually breaks
hardlinks. I can’t believe this is the default.

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

*** Require final newline at end of file

Not always what you want but most of the time, and, should definitively have
been the default especially on bash. Things can get weird when your files don’t
end in a newline.

#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

*** Show Warning buffer when error

#+begin_src emacs-lisp
  (setq warning-minimum-level :error)
#+end_src

*** Frame Scroll and Resize

Without this, Emacs will try to resize itself to a specific column size. I can’t
believe nil is the default

#+begin_src emacs-lisp
  (when window-system
    (setq frame-inhibit-implied-resize t)
    (setq pixel-scroll-precision-mode t))
#+end_src

*** Set PATH from login shell

#+begin_src emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  "Set up Emacs' `exec-path' and PATH environment variable to match
that used by the user's shell.

This is particularly useful under Mac OS X and macOS, where GUI
apps are not started from a shell."
  (interactive)
  (let ((path-from-shell (shell-command-to-string
                      "$SHELL --login -c 'echo -n $PATH'"
                            )))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))

(set-exec-path-from-shell-PATH)
#+end_src

*** Start Server Mode

#+begin_src emacs-lisp
  (setq server-socket-dir "~/.emacs.d/server/")
  ;; (unless (and (fboundp 'server-running-p)
  ;;              (server-running-p))
  ;;   (server-start))
#+end_src

*** Misc Defaults

#+begin_src emacs-lisp
      (setq-default
       cursor-type 'box                                 ; cursor type
       ad-redefinition-action 'accept                   ; Silence warnings for redefinition
       cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
       display-time-default-load-average nil            ; Don't display load average
       fill-column 80                                   ; Set width for automatic line breaks
       help-window-select t                             ; Focus new help windows when opened
       indent-tabs-mode nil                             ; Prefer spaces over tabs
       inhibit-startup-screen t                         ; Disable start-up screen
       initial-scratch-message ""                       ; Empty the initial *scratch* buffer
       kill-ring-max 128                                ; Maximum length of kill ring
       load-prefer-newer t                              ; Prefer the newest version of a file
       mark-ring-max 128                                ; Maximum length of mark ring
       read-process-output-max (* 10 1024 1024)         ; Increase the amount of data reads from the process
       scroll-conservatively most-positive-fixnum       ; Always scroll by one line
       select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
       tab-width 4                                      ; Set width for tabs
       use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
       user-full-name "Shaowei Wang"                    ; Set the full name of the current user
       user-mail-address "shaowei.wang@qq.com"          ; Set the email address of the current user
       vc-follow-symlinks t                             ; Always follow the symlinks
       view-read-only t                                 ; Always open read-only buffers in view-mode
       visible-bell t                                   ; Just need it
       frame-title-format
        (list (format "%s %%S: %%j " (system-name))
          '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))

    (column-number-mode 1)                            ; Show the column number
    (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
    (set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
    (show-paren-mode 1)                               ; Show the parent
    (menu-bar-mode -1)                              ; hide the menu bar
    (tool-bar-mode -1)                              ; hide the tool bar
    (scroll-bar-mode -1)                            ; hide the scroll bar
    (tooltip-mode -1)                               ; hode the tooltip

    ;; setup in terminal mode
    (add-hook 'tty-setup-hook (lambda ()
                                (menu-bar-mode -1)))

#+end_src

** Customizations

To avoid overloading the GNU Emacs customization =init.el= file made with the UI,
I add the generated code in a separate file.

#+begin_src emacs-lisp
  (setq custom-file (locate-user-emacs-file "custom.el"))
#+end_src
** Fonts

Spending most of our time on GNU Emacs, it is important to use a font that will
make our reading easier.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Maple Mono NF CN:style=Regular")
  (set-fontset-font t 'latin "Maple Mono NF CN:style=Regular")
  (set-fontset-font t 'han "Maple Mono NF CN:style=Regular")
  (add-to-list 'default-frame-alist '(font . "Maple Mono NF CN:style=Regular"))

  (use-package default-text-scale
    :config
    (default-text-scale-mode))
#+end_src
** Themes
I am a fan of [[https://github.com/ChrisKempson/Tomorrow-Theme][tomorrow-night]] and combined with [[https://github.com/seagle0128/doom-modeline][doom-modeline]] it's happiness! To
get icons in the =doom-modeline=, you will need to install [[#icons][icons]].

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ; (load-theme 'doom-tomorrow-night t)
    ;;(load-theme 'doom-palenight t)
    ; (load-theme 'doom-one-light t)
    (doom-themes-org-config))

  (use-package doom-modeline
    :init
    (display-time-mode 1)
    (doom-modeline-mode 1)
    :custom
    (doom-modeline-icon (display-graphic-p))
    (doom-modeline-buffer-encoding t)
    (doom-modeline-time t)
    (doom-modeline-time-icon t))

#+end_src

Since we do not do things by halves, it is also interesting to visually
differentiate "real" buffers (e.g., buffers that contain our work) from "unreal"
buffers (e.g., popups) by giving the latter a darker color. From then on,
[[https://github.com/hlissner/emacs-solaire-mode][solar-mode]] is the ideal package.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :defer 0.1
    :custom (solaire-mode-remap-fringe t)
    :config (solaire-global-mode))
#+end_src

An emacs theme that’s well suited for prose: particularly org-mode and
markdown-mode; or any mode that works well with variable-pitch mode.

#+begin_src emacs-lisp
(use-package poet-theme)
#+end_src

** OS System

*** Mac OS
#+begin_src emacs-lisp
  ;(when (eq system-type 'darwin)
   ; (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    ;(add-to-list 'default-frame-alist '(ns-appearance . dark)))
  (use-package ns-auto-titlebar
    :config
    (when (eq system-type 'darwin) (ns-auto-titlebar-mode)))
#+end_src

* Language Server
#+begin_src emacs-lisp
  (use-package eglot
    :ensure nil
    :custom
    (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    (eglot-events-buffer-config '(:size 0 :format full))
    (eglot-prefer-plaintext t)
    (jsonrpc-event-hook nil)
    (eglot-code-action-indications nil) ;; EMACS-31 -- annoying as hell
    :init
    (fset #'jsonrpc--log-event #'ignore)

    (setq-default eglot-workspace-configuration (quote
                                                 (:gopls (:hints (:parameterNames t)))))

    (defun emacs-solo/eglot-setup ()
      "Setup eglot mode with specific exclusions."
      (unless (or (eq major-mode 'emacs-lisp-mode) (eq major-mode 'lisp-mode))
        (eglot-ensure)))

    (add-hook 'prog-mode-hook #'emacs-solo/eglot-setup)

    :bind (:map
           eglot-mode-map
           ("C-c l a" . eglot-code-actions)
           ("C-c l o" . eglot-code-action-organize-imports)
           ("C-c l r" . eglot-rename)
           ("C-c l f" . eglot-format)))
#+end_src

* Management

Section dedicated to managing buffers, files, and windows on GNU Emacs to
provide a more pleasant experience.

** Neotree

A Emacs tree plugin like NerdTree for Vim.

#+begin_src emacs-lisp
  (use-package neotree
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    :bind ("<f8>" . neotree-toggle))
#+end_src

** Buffers

Buffers can quickly become a mess to manage. To manage them better, I use the
=ibuffer= built-in package instead of =buffer-menu=, to have a nicer visual
interface with a syntax color.

In addition, some buffers may contain useful temporary information that should
not be killed by accident. I make sure to set the buffers =*scratch*= and
=*Messages*= to read-only.

#+begin_src emacs-lisp
  (use-package ibuffer
    :ensure nil
    :preface
    (defvar protected-buffers '("*scratch*" "*Messages*")
      "Buffer that cannot be killed.")

    (defun my/protected-buffers ()
      "Protect some buffers from being killed."
      (dolist (buffer protected-buffers)
        (with-current-buffer buffer
          (emacs-lock-mode 'kill))))
    :bind ("C-x C-b" . ibuffer)
    :init (my/protected-buffers))
#+end_src

For buffer navigation, the next function is a more efficient way to go to the
beginning of a line with =move-beginning-of-line= (=C-a=) and =back-to-indentation=
(=M-m=).

#+begin_src emacs-lisp
  (use-package imenu
    :ensure nil
    :preface
    (defun my/smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

     Move point to the first non-whitespace character on this line.
     If point is already there, move to the beginning of the line.
     Effectively toggle between the first non-whitespace character and
     the beginning of the line.

     If ARG is not nil or 1, move forward ARG - 1 lines first. If
     point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))

      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))
    :bind (("C-a" . my/smarter-move-beginning-of-line)
           ("C-r" . imenu)))
#+end_src

Finally, it is useful to be able to move a line or a region up and down without
having to =kill-region= (=C-w=) and =yank (C-y)=. With the =move-text-up= and
=move-text-down= commands, the [[https://github.com/emacsfodder/move-text][move-text]] package allows to moves the current line
or if marked, the current region's, whole lines.

#+begin_src emacs-lisp
  (use-package move-text
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down))
    :config (move-text-default-bindings))
#+end_src

** Files

To manage your files, =dired= is already a good file manager. To fine-tune its
use, let's change some default values.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (:map dired-mode-map
                ("h" . dired-up-directory)
                ("j" . dired-next-line)
                ("k" . dired-previous-line))
    :delight "Dired"
    :config
    (when (eq system-type 'darwin)
      (setq dired-use-ls-dired t
            insert-directory-program "gls"))
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always))
#+end_src

To know the type of file at a glance, [[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]] integrates icons
directly into =dired=.

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :if (display-graphic-p)
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

It is sometimes convenient to hide dotfiles. With [[https://github.com/mattiasb/dired-hide-dotfiles][dired-hide-dotfiles]] this
becomes possible.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :bind (:map dired-mode-map
                ("H" . dired-hide-dotfiles-mode)))
#+end_src
I like being able to =<TAB>= on a folder and see its contents, without me getting
into it. [[https://github.com/Fuco1/dired-hacks/blob/master/dired-subtree.el][dired-subtree]] allows this behavior.

#+begin_src emacs-lisp
  (use-package dired-subtree
    :after dired
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))
#+end_src

Finally, to manage folders with a large number of files, it may be useful to
filter with [[https://github.com/Fuco1/dired-hacks/blob/master/dired-narrow.el][dired-narrow]]

#+begin_src emacs-lisp
  (use-package dired-narrow
    :ensure nil
    :bind (("C-c C-n" . dired-narrow)
           ("C-c C-f" . dired-narrow-fuzzy)))
#+end_src

** Windows

Most of the time, I want to split a window and put the focus on it to perform an
action. By default GNU Emacs does not give the focus to this new window. I have
no idea why this is not the default behavior, but we can easily set this
behavior.

#+begin_src emacs-lisp
  (use-package window
    :ensure nil
    :bind (("C-x 2" . vsplit-last-buffer)
           ("C-x 3" . hsplit-last-buffer)
           ;; Don't ask before killing a buffer.
           ([remap kill-buffer] . kill-current-buffer))
    :preface
    (defun hsplit-last-buffer ()
      "Focus to the last created horizontal window."
      (interactive)
      (split-window-horizontally)
      (other-window 1))

    (defun vsplit-last-buffer ()
      "Focus to the last created vertical window."
      (interactive)
      (split-window-vertically)
      (other-window 1)))
#+end_src

The way I move between several windows in GNU Emacs is by indicating the number
of the window I want to move to. Most people use [[https://github.com/abo-abo/ace-window][ace-window]], but I prefer
[[https://github.com/dimitri/switch-window][switch-window]] which displays the window number while hiding its content. I find
this behavior more convenient than moving from window to window to get to the
one we are looking for.

#+begin_src emacs-lisp
  (use-package switch-window
    :bind (("C-x o" . switch-window)
           ("C-x w" . switch-window-then-swap-buffer)))
#+end_src

* Minibuffer Completion

Having a good minibuffer completion is important on GNU Emacs since it is one of
the elements we will frequently interact with. In the beginning I used [[https://github.com/emacs-helm/helm][helm]], but
I found it to be memory intensive for the few features I was using. From this
observation I switched to [[https://github.com/abo-abo/swiper][ivy]] for many years, which is a faster and a lighter
framework than =helm=. However, =ivy= is still a framework.

Since then, newer completion systems have emerged (e.g., [[https://github.com/minad/vertico][vertico]], [[https://github.com/minad/vertico][selectrum]],
and [[https://github.com/oantolin/icomplete-vertical][icomplete-vertical]]), designed to be optimized for a single task and nested
with other packages with the same vision. That's why I now use =vertico= instead
of =ivy=.

*NOTE*: =selectrum= is also a good alternative to =ivy=, but is less minimal than
=vertico=.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init (vertico-mode)
    :bind (:map vertico-map
                ("C-<backspace>" . vertico-directory-up))
    :custom (vertico-cycle t))
#+end_src

To enable richer annotations (e.g., summary documentation of the functions and
variables, as well as having the size and the last consultation of the files)
for minibuffer completions, [[https://github.com/minad/marginalia/][marginalia]] is awesome.

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :init (marginalia-mode)
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

If like me you like to have icons associated with candidates, you can use
[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]].

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))
#+end_src

By default, =vertico= sorts the candidates according to their history position,
then by length and finally by alphabetical. To improves searching across
completion (e.g., by filter expressions separated by spaces), you should
use [[https://github.com/oantolin/orderless][orderless]] (or [[https://github.com/raxod502/prescient.el][prescient]]).

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles . (partial-completion)))))
    (completion-styles '(orderless)))
#+end_src

There is nothing like a collection of commands to have additional
completions. [[https://github.com/minad/consult][consult]] provides this collection.

#+begin_src emacs-lisp
  (use-package consult
    :after projectile
    :bind  (;; Related to the control commands.
            ("<help> a" . consult-apropos)
            ("C-x b" . consult-buffer)
            ("C-x M-:" . consult-complex-command)
            ("C-c k" . consult-kmacro)
            ;;
            ("M-y" . consult-yank-pop)
            ;; Related to the navigation.
            ("M-g a" . consult-org-agenda)
            ("M-g e" . consult-error)
            ("M-g g" . consult-goto-line)
            ("M-g h" . consult-org-heading)
            ("M-g i" . consult-imenu)
            ("M-g k" . consult-global-mark)
            ("M-g l" . consult-line)
            ("M-g m" . consult-mark)
            ("M-g o" . consult-outline)
            ;; Related to the search and selection.
            ("M-s G" . consult-git-grep)
            ("M-s g" . consult-grep)
            ("M-s k" . consult-keep-lines)
            ("M-s l" . consult-locate)
            ("M-s m" . consult-multi-occur)
            ("M-s r" . consult-ripgrep)
            ("M-s u" . consult-focus-lines)
            ("M-s f" . consult-find))
    :custom
    (completion-in-region-function #'consult-completion-in-region)
    (consult-narrow-key "<")
    (consult-project-root-function #'projectile-project-root)
    (register-preview-delay 0))
#+end_src

* Auto-Completion

Auto-completion with GNU Emacs is mainly combined with LSP mode.  Therefore the
development of any programming language is made easier with auto-completion,
which involves a completion at point followed by the display of a small pop-in
containing the candidates.

Nowadays there are two main possibilities: [[https://github.com/company-mode/company-mode][company-mode]] and [[https://github.com/minad/corfu][corfu]]. Personally I
have tried to make an attempt with =corfu= but I always prefer =company-mode= as it
seems to be easier and smoother to configure.

#+begin_src emacs-lisp
  (use-package company
    :init (global-company-mode)
    :custom
    (company-idle-delay 0.3)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-tooltop-flip-when-above t)
    :bind
    (:map company-mode-map
          ("M-/" . company-complete)))
#+end_src

To get nice candidate icons differentiating a function from a variable at a
glance, I use [[https://github.com/sebastiencs/company-box/][company-box]].

#+begin_src emacs-lisp
  (use-package company-box
    :if (display-graphic-p)
    :after company
    :hook (company-mode . company-box-mode))
#+end_src

* Spelling

No one is immune to spelling mistakes. It is therefore crucial to check our
spelling when we write documents, reply to an email or perform any other writing
task. With =abbrev=, =flyspell=, =ispell=, and LanguageTool, you will have the weapons
to reduce those nasty little spelling and grammar mistakes.

** Abbreviations

According to a list of misspelled words, the =abbrev= built-in package
automatically corrects these words on the fly.

*NOTE:* to start with a comfortable list, you can save the common misspellings
from Wikipedia (cf. [[https://www.masteringemacs.org/article/correcting-typos-misspellings-abbrev][Correcting Typos and Misspellings with Abbrev]])

#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :delight
    :hook (text-mode . abbrev-mode)
    :config
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))
#+end_src

** Fly Spell

I use the =flyspell= built-in package to enable spell checking on-the-fly in GNU
Emacs. A useful =flyspell= command is =flyspell-auto-correct-word= (=M-TAB=) which
automatically corrects a word according to the best suggestion.

*NOTE:* a call to =flyspell-buffer= could be extremely slow.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :delight
    ;; :hook ((text-mode . flyspell-mode)
    ;;        (prog-mode . flyspell-prog-mode))
    :custom
    ;; Add correction to abbreviation table.
    (flyspell-abbrev-p t)
    (flyspell-default-dictionary "en_US")
    (flyspell-issue-message-flag nil)
    (flyspell-issue-welcome-flag nil))
#+end_src

** Spell Checker

To correct spelling mistakes, the =ispell= built-in package use a spell checker
package (e.g., [[https://github.com/hunspell/hunspell][hunspell]] or [[https://github.com/GNUAspell/aspell][aspell]]). The =aspell= spell checker package would make
it easier to spot errors in camelCase, which can be handy when
programming. However, I personally use =hunspell= which only checks the spelling
of comments in the code and because it is more consistent on fly spells than
=aspell=.

To use =hunspell= you need to install it with your system package manager, as well
as install the desired language dictionaries (e.g., =hunspell-en_US=).

Finally, you can check that you have installed the language dictionaries by
using the =hunspell -D= command.

#+begin_src emacs-lisp
  (use-package ispell
    :custom
    (ispell-hunspell-dict-paths-alist
     '(("en_US" "/usr/share/hunspell/en_US.aff")))
    ;; Save words in the personal dictionary without asking.
    (ispell-silently-savep t)
    :config
    (setenv "LANG" "en_US")
    (cond ((executable-find "hunspell")
           (setq ispell-program-name "hunspell")
           (setq ispell-local-dictionary-alist '(("en_US"
                                                  "[[:alpha:]]"
                                                  "[^[:alpha:]]"
                                                  "['’-]"
                                                  t
                                                  ("-d" "en_US" )
                                                  nil
                                                  utf-8))))
          ((executable-find "aspell")
           (setq ispell-program-name "aspell")
           (setq ispell-extra-args '("--sug-mode=ultra"))))
    ;; Ignore file sections for spell checking.
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_align" . "#\\+end_align"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_align*" . "#\\+end_align*"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation" . "#\\+end_equation"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation*" . "#\\+end_equation*"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_labeling" . "#\\+end_labeling"))
    (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
    (add-to-list 'ispell-skip-region-alist '("\\$" . "\\$"))
    (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:")))
#+end_src

* Programming Languages and Tools
** Bash

Being a UNIX user, I often do Bash. Since GNU Emacs already supports it, I only
use the [[https://emacs-lsp.github.io/lsp-mode/page/lsp-bash/][bash-language-server]] (=bash-ls=) as LSP server. To use it, do not forget
to configure the LSP package and to install this LSP server through LSP mode or
with your system package manager.

Finally, the following snippet ensures that execution right (with =chmod +x=) is
automatically granted to save a shell script file that begins with a =#!= shebang.

#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

** BBcode mode

Godot's BBcode mode

#+begin_src emacs-lisp
  (use-package bbcode-mode)
#+end_src

** Lua

I rarely program in Lua, but when I do, [[https://github.com/immerrr/lua-mode][lua-mode]] with [[https://emacs-lsp.github.io/lsp-mode/page/lsp-lua-language-server/][lua-language-server]] as LSP
server satisfies me amply. To use it, do not forget to configure the LSP package
and to install this LSP server through LSP mode or with your system package
manager.

#+begin_src emacs-lisp
  (use-package lua-mode :delight "Λ" :mode "\\.lua\\'")
#+end_src
** Gnuplot

Whether professionally or personally, it is often necessary to visualize your
data in a quality graph. [[http://www.gnuplot.info/][Gnuplot]] is the perfect tool for this and the[[https://github.com/emacsorphanage/gnuplot][ gnuplot]]
package allows to support this tool with GNU Emacs. To use gnuplot, do not
forget to install it with your system package manager.

#+begin_src emacs-lisp
  (use-package gnuplot
    :mode "\\.\\(gp\\|gpi\\|plt\\)'"
    :bind (:map gnuplot-mode-map
                ("C-c C-c".  gnuplot-send-buffer-to-gnuplot)))
#+end_src
** CMake

CMake is a cross-platform build system generator. For its support with GNU
Emacs, the [[https://github.com/Kitware/CMake/blob/master/Auxiliary/cmake-mode.el][cmake-mode]] package with the installation of the [[https://emacs-lsp.github.io/lsp-mode/page/lsp-cmake/][cmake-language-server]]
LSP server is sufficient. To use it, do not forget to configure the LSP package
and to install this LSP server through LSP mode or with your system package
manager.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :hook (cmake-mode . lsp-deferred)
    :mode ("CMakeLists\\.txt\\'" "\\.cmake\\'"))
#+end_src

To better manage syntax colors, especially with respect to function arguments,
it is visually useful to install [[https://github.com/Lindydancer/cmake-font-lock][cmake-font-lock]].
#+begin_src emacs-lisp
  (use-package cmake-font-lock
    :hook (cmake-mode . cmake-font-lock-activate))
#+end_src

** meson build

#+begin_src emacs-lisp
  (use-package meson-mode
    :custom
    (meson-indent-basic 4))
#+end_src

** C++

** swift

#+begin_src emacs-lisp
    (use-package swift-mode
      :ensure t)
#+end_src

** Common Lisp
the inferior-lisp-program should be set in custom file.
#+begin_src emacs-lisp
    (use-package sly
      :ensure t
      :custom
      (org-babel-lisp-eval-fn 'sly-eval))         ;; org babel run lisp code in sly
#+end_src

** Sass/Scss

#+begin_src emacs-lisp
  (use-package sass-mode)
  (use-package scss-mode
    :init
    (setq flymake-allowed-file-name-masks nil)
    (setq flymake-err-line-patterns nil))
#+end_src

** LaTeX

Being a lover of beautiful writing, it is important for me to have a stable
LaTeX environment. To have access to this stability, I use the =tex-mode= built-in
package and [[https://github.com/latex-lsp/texlab][texlab]] as LSP server. To use it, make sure you install it with your
package manager and to configure the LSP package.

With =tex-mode= we need to ensure to install AUCTeX, which is a built-in package
for writing and formatting TeX files in GNU Emacs. With =AUCTeX you can for
example use the =TeX-command-master= (=C-c C-c=) command to compile your TeX files
and the =LaTeX-environment= (=C-c C-e=) command to insert a LaTeX environment.

#+begin_src emacs-lisp
  (use-package tex
    :ensure auctex
    :preface
    (defun my/switch-to-help-window (&optional ARG REPARSE)
      "Switches to the *TeX Help* buffer after compilation."
      (other-window 1))
    :hook (LaTeX-mode . reftex-mode)
    :bind (:map TeX-mode-map
                ("C-c C-o" . TeX-recenter-output-buffer)
                ("C-c C-l" . TeX-next-error)
                ("M-[" . outline-previous-heading)
                ("M-]" . outline-next-heading))
    :custom
    (TeX-auto-save t)
    (TeX-byte-compile t)
    (TeX-clean-confirm nil)
    (TeX-master 'dwim)
    (TeX-parse-self t)
    (TeX-PDF-mode t)
    (TeX-source-correlate-mode t)
    (TeX-view-program-selection '((output-pdf "PDF Tools")))
    :config
    (advice-add 'TeX-next-error :after #'my/switch-to-help-window)
    (advice-add 'TeX-recenter-output-buffer :after #'my/switch-to-help-window)
    ;; the ":hook" doesn't work for this one... don't ask me why.
    (add-hook 'TeX-after-compilation-finished-functions 'TeX-revert-document-buffer))

  (use-package company-auctex
    :ensure t
    :after auctex
    :init
    (company-auctex-init))
#+end_src

Also, I like to use a TeX engine that can handle Unicode and use the font of my
choice.

#+begin_src emacs-lisp
  (setq-default TeX-engine 'xetex)
#+end_src

By default, LSP mode uses =lsp-tex= as the LSP client for LaTeX. However, I prefer
to use [[https://github.com/ROCKTAKEY/lsp-latex][lsp-latex]] which fully supports =texlab=
(cf. https://github.com/ROCKTAKEY/lsp-latex/issues/26)

#+begin_src emacs-lisp
  (use-package lsp-latex
    :if (executable-find "texlab")
    ;; To properly load `lsp-latex', the `require' instruction is important.
    :hook (LaTeX-mode . (lambda ()
                          (require 'lsp-latex)
                          (lsp-deferred)))
    :custom (lsp-latex-build-on-save t))
#+end_src

To easier deal with =\label=, =\ref=, and =\cite= commands in LaTeX, I use the =reftex=
built-in package.

#+begin_src emacs-lisp
  (use-package reftex
    :ensure nil
    :custom
    (reftex-save-parse-info t)
    (reftex-use-multiple-selection-buffers t))
#+end_src

Finally, it is often useful to put our hands in a bibliography in LaTeX. The built-in
package =bibtex= improves the visual and provides several commands.

#+begin_src emacs-lisp
  (use-package bibtex
    :ensure nil
    :preface
    (defun my/bibtex-fill-column ()
      "Ensure that each entry does not exceed 120 characters."
      (setq fill-column 120))
    :hook ((bibtex-mode . lsp-deferred)
           (bibtex-mode . my/bibtex-fill-column)))
#+end_src

** Markdown

To edit my files in Markdown, I use [[https://github.com/jrblevin/markdown-mode][markdown-mode]] with [[https://emacs-lsp.github.io/lsp-mode/page/lsp-markdown/][unified-language-server]]
as LSP server. To use it, do not forget to configure the LSP package and to
install this LSP server with your system package manager. Added to that, to
convert Markdown files, you can also install [[https://github.com/jgm/pandoc][pandoc]] with your package manager
system.

#+begin_src emacs-lisp
    (use-package markdown-mode
      :delight "μ"
      :mode ("\\.\\(md\\|markdown\\)\\'")
      :custom (markdown-command "/usr/bin/pandoc"))

    (use-package markdown-toc
      :bind ("C-c C-g" . markdown-toc-follow-link-at-point))
#+end_src

Finally, it is always good to have a preview of the Markdown rendering. The
[[https://github.com/ancane/markdown-preview-mode][markdown-preview-mode]] package allows this.

#+begin_src emacs-lisp
  (use-package markdown-preview-mode
    :commands markdown-preview-mode
    :custom
    (markdown-preview-javascript
     (list (concat "https://github.com/highlightjs/highlight.js/"
                   "9.15.6/highlight.min.js")
           "<script>
              $(document).on('mdContentChange', function() {
                $('pre code').each(function(i, block)  {
                  hljs.highlightBlock(block);
                });
              });
            </script>"))
    (markdown-preview-stylesheets
     (list (concat "https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/"
                   "3.0.1/github-markdown.min.css")
           (concat "https://github.com/highlightjs/highlight.js/"
                   "9.15.6/styles/github.min.css")

           "<style>
              .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 980px;
                margin: 0 auto;
                padding: 45px;
              }

              @media (max-width: 767px) { .markdown-body { padding: 15px; } }
            </style>")))
#+end_src

* Advanced Configuration
** epa
#+begin_src emacs-lisp
  (use-package epa
    :custom
    (epa-file-cache-passphrase-for-symmetric-encryption t))
#+end_src
** Calculator

On a daily basis, you may have to make calculations or conversions from one unit
to another. With the =calc= build-in package (=C-x * c=) it is possible to do this easily
with GNU Emacs.

Among the useful commands within =calc= that you should know:
- =calc-algebraic-entry=: allows you to enter a value and its unit to later
  to convert it or associate it with an operation.
- =calc-convert-units= (=u c=): converts the output of an algebraic entry (e.g., =25 m= → =25000 mm=).
- =calc-simplify-units= (=u s=): simplifies the output of an algebraic entry (e.g., =5 m + 23 m= → =5.023 m=).
- =calc-view-units-table= (=u V=): displays a table of units supported by calc.

#+begin_src emacs-lisp
  (use-package calc
    :ensure nil
    :custom
    (math-additional-units
     '((GiB "1024 * MiB" "Giga Byte")
       (MiB "1024 * KiB" "Mega Byte")
       (KiB "1024 * B" "Kilo Byte")
       (B nil "Byte")
       (Gib "1024 * Mib" "Giga Bit")
       (Mib "1024 * Kib" "Mega Bit")
       (Kib "1024 * b" "Kilo Bit")
       (b "B / 8" "Bit")))
    ;; Resets the calc's cache.
    (math-units-table nil))
#+end_src

** Color Display in Text

To automatically display a color when typing a color or hex code values, the
[[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]] package is useful.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :delight
    :hook ((prog-mode text-mode) . rainbow-mode))
#+end_src

** Dashboard

Organization is even more important in the 21st century than it was before. What
could be better than launching GNU Emacs with a dashboard that lists the tasks
of the week with =org-agenda= and a list of projects we have recently contributed
to with =projectile=. To our delight the [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] package offers these features
and more.

#+begin_src emacs-lisp
  (use-package dashboard
    :custom
    (dashboard-banner-logo-title "Welcome to Emacs!")
    (dashboard-center-content t)
    (dashboard-vertically-center-content t)
    (dashboard-items '((bookmarks . 5)
                       (recents . 5)))
    (dashboard-set-file-icons t)
    (dashboard-set-footer nil)
    (dashboard-set-heading-icons t)
    (dashboard-set-navigator t)
    (dashboard-startup-banner 'logo)
    :config (dashboard-setup-startup-hook))
#+end_src

** Displays Available Keybindings in Popup

It is difficult to remember every keyboard shortcuts. The [[https://github.com/justbur/emacs-which-key][which-key]] package
helps to solve this.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 0.2
    :delight
    :custom (which-key-idle-delay 0.6)
    :config (which-key-mode))
#+end_src

** Documentation

To have a more user-friendly documentation I use the [[https://github.com/Wilfred/helpful][helpful]] package.

#+begin_src emacs-lisp
  (use-package helpful
    :commands (helpful-at-point
               helpful-callable
               helpful-command
               helpful-function
               helpful-key
               helpful-macro
               helpful-variable)
    :bind
    ([remap display-local-help] . helpful-at-point)
    ([remap describe-function] . helpful-callable)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-key] . helpful-key)
    ([remap describe-command] . helpful-command))
#+end_src

** Icons

To integrate icons with =doom-modeline= and other packages, [[https://github.com/domtronn/all-the-icons.el/][all-the-icons]] is the
best package that you can have with GNU Emacs. To download the icons on your
machine, you must run the =all-the-icons-install-fonts= command when you install
this package.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p)
    :commands all-the-icons-install-fonts
    :config (unless (find-font (font-spec :name "all-the-icons"))
              (all-the-icons-install-fonts t)))
  (use-package nerd-icons
    :if (display-graphic-p)
    :commands nerd-icons-install-fonts
    :config (unless (find-font (font-spec :name "Symbols Nerd Font Mono"))
              (nerd-icons-install-fonts t)))
#+end_src

** Indentations

By default GNU Emacs auto-indents the code while typing with
=electric-indent-mode=, but the indentation made is wrong when moving blocks,
transposing lines and so on. The [[https://github.com/Malabarba/aggressive-indent-mode][aggresive-indent]] package is an improved version
of the previous mode, allowing a code to be always indented.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :custom (aggressive-indent-comments-too t))
#+end_src

With code nesting, it is important to always have a discrete visual on the
indentation of our code. The [[https://github.com/DarthFennec/highlight-indent-guides/][highlight-indent-guides]] package allows you to see
at a glance if an indentation is bad through block highlight.

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook (prog-mode . highlight-indent-guides-mode)
    :custom (highlight-indent-guides-method 'character))
#+end_src

** Parentheses

Managing parentheses can be painful. One of the first things you want to do is
to change the appearance of the highlight of the parentheses pairs.

#+begin_src emacs-lisp
  (use-package faces
    :ensure nil
    :custom (show-paren-delay 0)
    :config
    (set-face-background 'show-paren-match "#161719")
    (set-face-bold 'show-paren-match t)
    (set-face-foreground 'show-paren-match "#ffffff"))
#+end_src

Then, I also like to highlight brackets and other delimiters (e.g., brackets or
braces) with a different color, depending on their depth. The [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]
package allows such behavior.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Finally, to manage your parenthesis, I recommend to use [[https://github.com/Fuco1/smartparens][smartparens]] which is in
my opinion a better alternative to [[https://github.com/emacsmirror/paredit][paredit]] or to the built-in =electric-pair-mode=
package.

#+begin_src emacs-lisp
  (use-package smartparens
    :delight
    :hook (prog-mode . smartparens-mode)
    :custom (sp-escape-quotes-after-insert nil))
#+end_src

** Snippets

#+begin_src emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode "υ"
    :hook (yas-minor-mode . my/disable-yas-if-no-snippets)
    :config (yas-global-mode)
    :preface
    (defun my/disable-yas-if-no-snippets ()
      (when (and yas-minor-mode (null (yas--get-snippet-tables)))
        (yas-minor-mode -1))))

  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

#+end_src

** Spaces Around the Operators

To automatically add spacing around operators as you develop, the
[[https://github.com/davidshepherd7/electric-operator][electric-operator]] package is there for that.

*NOTE:* I don't use =electric-operator= for C-like languages which works a bit less
well according to the author of the package.

#+begin_src emacs-lisp
  (use-package electric-operator
    :hook ((css-mode java-mode js2-mode
                    python-mode sql-mode typescript-mode) . electric-operator-mode))
#+end_src

** Recent Files

It could be useful to have easy access to recently modified files.

#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :bind ("C-c f" . consult-recent-file)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"
                           "~$"
                           "COMMIT_EDITMSG"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    ;; Save recent files every 5 minutes to manage abnormal output.
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+end_src

** Version Control System

It is quite common to work on [[https://git-scm.com/][Git]] repositories, therefore it is important to
have a configuration that suits us. To interact with Git, GNU Emacs has [[https://github.com/magit/magit][magit]]
which is the best tool I have tested. With =magit= you can directly interact with
your repositories through an interface.

#+begin_src emacs-lisp
  (use-package magit
    :commands magit-status
    :bind
    (("C-x g" . magit-status))
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

Finally, I like to know the modified lines of a file while I edit it.

#+begin_src emacs-lisp
  (use-package git-gutter
    :defer 0.3
    :delight
    :config (global-git-gutter-mode))
#+end_src

** PDF

By default, opening PDFs under GNU Emacs sucks. Fortunately, the [[https://github.com/vedang/pdf-tools][pdf-tools]]
package provides =pdf-view= to offer a better support for PDFs.

*NOTE:* If =pdf-tools= fails to open a PDF, please execute the =pdf-tools-install=
command.
(When using mac, I do not use pdf-tools)

#+begin_src emacs-lisp
  (unless (eq system-type 'darwin)
    (use-package pdf-tools
      :magic ("%PDF" . pdf-view-mode)
      :init (pdf-tools-install :no-query)))
#+end_src

To be comfortable with PDFs, let's customize [[https://github.com/politza/pdf-tools/blob/master/lisp/pdf-view.el][pdf-view]] which is a major mode part
of the =pdf-tools= package.

#+begin_src emacs-lisp
  (use-package pdf-view
    :ensure nil
    :after pdf-tools
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward)
                ("d" . pdf-annot-delete)
                ("h" . pdf-annot-add-highlight-markup-annotation)
                ("t" . pdf-annot-add-text-annotation))
    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-resize-factor 1.1)
    ;; Avoid searching for unicodes to speed up pdf-tools.
    (pdf-view-use-unicode-ligther nil)
    ;; Enable HiDPI support, at the cost of memory.
    (pdf-view-use-scaling t))
#+end_src

** Project Interactions

To interact with your projects characterized by a folder with at least one
special file (e.g., a VCS marker or a project descriptor file like =pom.xml= or
=Gemfile=), the [[https://github.com/bbatsov/projectile][projectile]] package is a must on GNU Emacs.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish (projectile-mode)
    :custom
    (projectile-enable-caching t)
    ;; (projectile-keymap-prefix (kbd "C-c C-p"))
    (projectile-mode-line '(:eval (projectile-project-name)))
    ;; Define the folder containing git repositories (e.g., ~/.local/share/git).
    (projectile-switch-project-action #'projectile-dired)
    :config (projectile-global-mode))
#+end_src

I also use =projectile= with =consult= through the [[https://gitlab.com/OlMon/consult-projectile][counsult-projectile]] package.

#+begin_src emacs-lisp
  (use-package consult-projectile
    :after (consult projectile)
    :commands (consult-projectile))
#+end_src

Finally, [[https://github.com/purcell/ibuffer-projectile][ibuffer-projectile]] is helpful to group the buffers in the =ibuffer= list
by [[#projectile][projectile]] project.

#+begin_src emacs-lisp
  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+end_src

** Whitespaces and Kill

It is annoying to see useless blank spaces at the end of a line or a file. Let's
get rid of these spaces. Most of the time, I also like to have justified texts.

#+begin_src emacs-lisp
  ;; (use-package simple
  ;;   :ensure nil
  ;;   :delight (auto-fill-function)
  ;;   :preface
  ;;   (defun my/kill-region-or-line ()
  ;;     "When called interactively with no active region, kill the whole line."
  ;;     (interactive)
  ;;     (if current-prefix-arg
  ;;         (progn
  ;;           (kill-new (buffer-string))
  ;;           (delete-region (point-min) (point-max)))
  ;;       (progn (if (use-region-p)
  ;;                  (kill-region (region-beginning) (region-end) t)
  ;;                (kill-region (line-beginning-position) (line-beginning-position
  ;;                                                        2))))))
  ;;   :hook ((before-save . delete-trailing-whitespace)
  ;;          ((prog-mode text-mode) . turn-on-auto-fill))
  ;;   :bind ("C-w" . my/kill-region-or-line)
  ;;   :custom (set-mark-command-repeat-pop t))
#+end_src

Finally, I also like is to be able to delete every consecutive space characters
when a space character is deleted. The [[https://github.com/nflath/hungry-delete][hungry-delete]] package allows this
behavior.

#+begin_src emacs-lisp
  (use-package hungry-delete
    :defer 0.7
    :delight
    :config (global-hungry-delete-mode))
#+end_src

* Eshell
#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil
    :bind
    (("C-c e" . eshell))
    :defer t
    :hook
    (eshell-mode . (lambda () (setenv "TERM" "xterm-256color")))
    :config
    (setopt eshell-banner-message
            (concat
             (propertize " ✨ Welcome to the Emacs Shell ✨\n\n" 'face '(:weight bold :foreground "#f9e2af")))))

#+end_src

* Org Mode

[[https://orgmode.org/][Org Mode]] is one of my favorite modes in GNU Emacs. I mainly use it to write
notes and manage my time to enjoy a better organization of my life, but you can
do lots of things with it. It is like the sky, without limits.

** First Steps

To use Org Mode, GNU Emacs already has the =org= built-in package. However, some
extra packages are in the [[https://elpa.nongnu.org/nongnu/org-contrib.html][org-contrib]] package. It is therefore a good idea to
install it.
#+begin_src emacs-lisp
  (use-package org
    :ensure t
    :delight "Θ"
    :hook (org-mode . turn-off-auto-fill)
    :bind ("C-c i" . org-insert-structure-template)
    :preface
    (defun my/org-archive-done-tasks ()
      "Archive finished or cancelled tasks."
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "TODO=\"DONE\"|TODO=\"CANCELLED\"" (if (org-before-first-heading-p) 'file 'tree)))

    (defun my/org-jump ()
      "Jump to a specific task."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'org-refile)))

    (defun my/org-use-speed-commands-for-headings-and-lists ()
      "Activate speed commands on list items too."
      (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
          (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))

    (defun my/org-redisplay-image-after-babel ()
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))

    (defmacro ignore-args (fnc)
      "Returns function that ignores its arguments and invokes FNC."
      `(lambda (&rest _rest)
         (funcall ,fnc)))
    :hook ((auto-save . org-save-all-org-buffers)
           (org-babel-after-execute . my/org-redisplay-image-after-babel)
           (org-mode . visual-line-mode))
    :custom
    (org-startup-folded t)
    (org-babel-load-languages '((lisp . t)
                                (emacs-lisp . t)
                                (mermaid . t)
                                (dot . t)))
    (org-blank-before-new-entry '((heading . t)
                                  (plain-list-item . t)))
    (org-confirm-babel-evaluate nil)
    (org-cycle-include-plain-lists 'integrate)
    (org-ellipsis " ▾")
    (org-export-backends '(ascii beamer html icalendar latex man md org texinfo))
    (org-hide-emphasis-markers t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-modules '(org-crypt
                   org-habit
                   org-mouse
                   org-protocol
                   org-tempo))
    (org-refile-allow-creating-parent-nodes 'confirm)
    (org-refile-targets '((org-agenda-files :maxlevel . 1)))
    (org-refile-use-cache nil)
    (org-refile-use-outline-path nil)
    (org-startup-indented t)
    (org-startup-with-inline-images t)
    (org-tag-alist
     '((:startgroup . "Context")
       ("@errands" . ?e)
       ("@home" . ?h)
       ("@work" . ?w)
       (:endgroup)
       (:startgroup . "Difficulty")
       ("easy" . ?E)
       ("medium" . ?M)
       ("challenging" . ?C)
       (:endgroup)
       ("bug" . ?b)
       ("car" . ?v)
       ("future" . ?F)
       ("goal" . ?g)
       ("health" . ?H)
       ("house" . ?O)
       ("meeting" . ?m)
       ("planning" . ?p)
       ("phone" . ?0)
       ("purchase" . ?P)
       ("reading" . ?r)
       ("review" . ?R)
       ("study" . ?s)
       ("sport" . ?S)
       ("talk" . ?T)
       ("tech" . ?t)
       ("trip" . ?I)
       ("thinking" . ?i)
       ("update" . ?u)
       ("watch" . ?l)
       ("writing" . ?W)))
    (org-tags-exclude-from-inheritance '("crypt" "project"))
    (org-todo-keywords '((sequence "TODO(t)"
                                   "STARTED(s)"
                                   "NEXT(n)"
                                   "SOMEDAY(.)"
                                   "WAITING(w)""|" "DONE(x!)" "CANCELLED(c@)")))
    (org-use-effective-time t)
    (org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)
    (org-yank-adjusted-subtrees t)
    :config
    (add-to-list 'org-global-properties '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00"))
    (add-to-list 'org-speed-commands '("$" call-interactively 'org-archive-subtree))
    (add-to-list 'org-speed-commands '("i" call-interactively 'org-clock-in))
    (add-to-list 'org-speed-commands '("o" call-interactively 'org-clock-out))
    (add-to-list 'org-speed-commands '("s" call-interactively 'org-schedule))
    (add-to-list 'org-speed-commands '("x" org-todo "DONE"))
    (add-to-list 'org-speed-commands '("y" org-todo-yesterday "DONE"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (advice-add 'org-deadline :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-schedule :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-store-log-note :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-refile :after 'org-save-all-org-buffers)
    (advice-add 'org-todo :after (ignore-args #'org-save-all-org-buffers))
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (org-clock-persistence-insinuate)
    (org-load-modules-maybe t))
#+end_src

** Bullets

Let's add prettier bullets in Org Mode with [[https://github.com/sabof/org-bullets][org-bullets]].

#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom (org-bullets-bullet-list '("●" "►" "▸")))
#+end_src

** Faces

Let's change the foreground and the weight of each keyword.

#+begin_src emacs-lisp
  (use-package org-faces
    :ensure nil
    :custom
    (org-todo-keyword-faces
     '(("DONE"    . (:foreground "#8abeb7" :weight bold))
       ("NEXT"    . (:foreground "#f0c674" :weight bold))
       ("SOMEDAY" . (:foreground "#b294bb" :weight bold))
       ("TODO"    . (:foreground "#b5bd68" :weight bold))
       ("WAITING" . (:foreground "#de935f" :weight bold)))))
#+end_src

** Languages

Let's specify languages extra to Org Mode to compile them directly into =.org=
files.

#+begin_src emacs-lisp
  (use-package python :ensure nil :after org)
  (use-package ob-C :ensure nil :after org)
  (use-package ob-css :ensure nil :after org)
  (use-package ob-emacs-lisp :ensure nil :after org)
  (use-package ob-gnuplot :ensure nil :after org)
  (use-package ob-dot :ensure nil :after org)
  (use-package ob-js :ensure nil :after org)
  (use-package ob-latex
    :ensure nil
    :after org
    :custom (org-latex-compiler "xelatex"))
  ;; (use-package ob-ledger :ensure nil :after org)
  (use-package ob-makefile :ensure nil :after org)
  (use-package ob-org :ensure nil :after org)
  (use-package ob-python :ensure nil :after org)
  (use-package ob-shell :ensure nil :after org)
#+end_src

*** mermaid

[[https://mermaid.js.org/][Mermaid]] is Diagramming and charting tool.

JavaScript based diagramming and charting tool that renders Markdown-inspired
text definitions to create and modify diagrams dynamically.

#+begin_src emacs-lisp
  (use-package ob-mermaid
    :ensure t
    :after org)
#+end_src



** Notes and Journal

Taking notes is a necessity in a world full of information. To take these notes
and interconnect them, the [[https://github.com/org-roam/org-roam][org-roam]] package is great.

After using [[https://github.com/bastibe/org-journal][org-journal]], I also decided to use =org-roam= to write my journal.

If you don't already do so, I advise you to start writing your journal. If you
haven't done so yet, I suggest you start writing your journal. This journal
would allow you, for example, to improve your mental clarity, follow your
evolution, and facilitate your personal growth.

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-completion-everywhere t)
    (org-roam-directory (file-truename "~/Sync/orgroam"))
    :bind
    (("C-c o f" . org-roam-node-find)
     ("C-c o o" . org-roam-buffer-toggle)
     :map org-mode-map
     ("C-c o i" . org-roam-node-insert))
    :config
    (org-roam-setup)
    (setq org-id-extra-files (directory-files-recursively org-roam-directory "\\.org$"))
    (add-to-list 'display-buffer-alist
                 '("\\*org-roam\\*"
                   (display-buffer-in-side-window)
                   (side . right)
                   (slot . 0)
                   (window-width . 0.33)
                   (window-parameters . ((no-other-window . t)
                                         (no-delete-other-windows . t))))))

#+end_src

** Present

#+begin_src emacs-lisp
  (use-package visual-fill-column
    :custom
    (visual-fill-column-width 120)
    (visual-fill-column-center-text t))

  (use-package org-present
    :after visual-fill-column
    :bind
    ("C-c p" . org-present)
    :preface
    (defun my/org-present-start ()
      ;; Center the presentation and wrap lines
      (visual-fill-column-mode 1)
      (visual-line-mode 1)
      ;;(org-present-big)
      (org-present-hide-cursor)
      (org-display-inline-images)
      (org-present-read-only))

    (defun my/org-present-end ()
      ;; Stop centering the document
      (visual-fill-column-mode 0)
      (visual-line-mode 0)
      ;;(org-present-small)
      (org-present-show-cursor)
      (org-remove-inline-images)
      (org-present-read-write))

    :hook
    ((org-present-mode . my/org-present-start)
     (org-present-mode-quit . my/org-present-end)))


#+end_src
* Misc Settings

** pulsar

Pulse highlight line on demand or after running select functions

#+begin_src emacs-lisp
  (use-package pulsar
    :ensure t
    :custom
    (pulsar-pulse t)
    (pulsar-delay 0.055)
    (pulsar-iterations 10)
    (pulsar-face 'pulsar-magenta)
    (pulsar-highlight-face 'pulsar-yellow)
    :config
    (pulsar-global-mode 1))
#+end_src

** Ag

A front-end for ag ('the silver searcher'), the C ack replacement.

#+begin_src emacs-lisp
  (use-package ag
    :ensure t)
#+end_src

** crux

A Collection of Ridiculously Useful eXtensions for Emacs. crux bundles many
useful interactive commands to enhance your overall Emacs experience.

#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind
    ("C-k" . crux-smart-kill-line)
    ("C-<return>" . crux-smart-open-line)
    ("C-S-<return>" . crux-smart-open-line-above))
#+end_src
* Load customize file

KEEP THIS AT LAST!!!

#+begin_src emacs-lisp
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src
